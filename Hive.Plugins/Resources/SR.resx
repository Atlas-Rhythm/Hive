<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AggregateWith_AlmostExpressionAggregator" xml:space="preserve">
    <value>Target method takes Expressions but does not return an Expression type</value>
  </data>
  <data name="AggregateWith_NoSuchAggregator" xml:space="preserve">
    <value>Could not find agggregator on {0} with name {1}</value>
    <comment>{0} is TypeWithAggregator, {1} is AggregatorName</comment>
  </data>
  <data name="Foreach_EnumerableInvalid" xml:space="preserve">
    <value>A foreach loop can only take IEnumerable and IEnumerable&lt;T&gt;</value>
  </data>
  <data name="Foreach_EnumeratorNotEnumerator" xml:space="preserve">
    <value>Enumerator for enumerable is not an enumerator</value>
  </data>
  <data name="Foreach_EnumeratorWithoutCurrent" xml:space="preserve">
    <value>Enumerator for enumerable does not have a Current property</value>
  </data>
  <data name="Foreach_IncorrectLoopVariable" xml:space="preserve">
    <value>Loop variable cannot be assigned from enumeration type {0}</value>
    <comment>{0} is the type of the values being enumerated</comment>
  </data>
  <data name="Foreach_NoPublicGetEnumerator" xml:space="preserve">
    <value>Enumerable has no public member GetEnumerator()</value>
  </data>
  <data name="Generator_AggregateMustBeAggregable" xml:space="preserve">
    <value>Aggregated interfaces must be marked [Aggregable]!</value>
  </data>
  <data name="Generator_AttributeInvalidOn" xml:space="preserve">
    <value>Attribute {0} invalid on parameter {1}</value>
    <comment>{0} is the attribute, {1} is the parameter its applied to</comment>
  </data>
  <data name="Generator_CanOnlyAggregateInterfaces" xml:space="preserve">
    <value>Aggregated instances can only be generated from interfaces!</value>
  </data>
  <data name="Generator_InvalidParameterIndex" xml:space="preserve">
    <value>On parameter {1}, invalid argument index {0}</value>
    <comment>{0} is the parameter index, {1} is the parameter its used on</comment>
  </data>
  <data name="Generator_MethodMayHaveOneOf" xml:space="preserve">
    <value>Method {0} cannot have both {1} and {2}</value>
    <comment>{0} is the method name, {1} is the first attribute, {2} is the second attribute</comment>
  </data>
  <data name="Generator_MethodMustReturnBoolToUse" xml:space="preserve">
    <value>Method {0} must return a boolean to use {1}</value>
    <comment>{0} is the method name, {1} is the attribute</comment>
  </data>
  <data name="Generator_MethodMustReturnEnumerableToUse" xml:space="preserve">
    <value>Method {0} must return a generic enumerable to use {1}</value>
    <comment>{0} is the method name, {1} is the attribute</comment>
  </data>
  <data name="Generator_MethodMustReturnNullableToUse" xml:space="preserve">
    <value>Method {0} must return a nullable type to use {1}</value>
    <comment>{0} is the method name, {1} is the attribute</comment>
  </data>
  <data name="Generator_OutParamNotCompatible" xml:space="preserve">
    <value>Target out parameter not compatible with parameter {0}</value>
    <comment>{0} is the declared parameter (the one that isn't an out param)</comment>
  </data>
  <data name="Generator_ParameterCannotTakeReturn" xml:space="preserve">
    <value>Parameter {0} cannot take return value</value>
    <comment>{0} is the parameter</comment>
  </data>
  <data name="Generator_ParameterNotOutParam" xml:space="preserve">
    <value>Parameter index {0} is not an out parameter</value>
    <comment>{0} is the parameter index</comment>
  </data>
  <data name="Generator_UnknownInputAttribute" xml:space="preserve">
    <value>Unknown input specifying attribute {0}</value>
    <comment>{0} is the attribute</comment>
  </data>
  <data name="PluginLoad_NoPluginFileInPluginDir" xml:space="preserve">
    <value>There is no file '{0}' in the plugin directory '{1}'; could not load the plugin.</value>
    <comment>{0} is the expected name of the plugin file, {1} is the path of the plugin directory</comment>
  </data>
  <data name="Utils_Inject_CouldNotResolveService" xml:space="preserve">
    <value>Could not resolve a service of type '{0}' for the parameter '{1}' of method '{2}' on type '{3}'.</value>
    <comment>{0} is the service type, {1} is the parameter name, {2} is the method being injected, {3} is the type the method is on</comment>
  </data>
  <data name="Utils_Inject_TooManyArguments" xml:space="preserve">
    <value>Too many arguments were provided during the injection of '{0}' on type '{1}'</value>
    <comment>{0} is the method being injected, {1} is the type the method is on</comment>
  </data>
</root>